<pre class='metadata'>
Title: Shared Storage API
Shortname: sharedStorage
Level: 1
Status: CG-DRAFT
Group: WICG
URL: https://github.com/WICG/shared-storage
Editor: Camillia Smith Barnes, Google https://google.com, cammie@chromium.org
Markup Shorthands: markdown yes
Abstract: Shared Storage is a storage API that is intentionally not partitioned by top-frame site (though still partitioned by context origin of course!). To limit cross-site reidentification of users, data in Shared Storage may only be read in a restricted environment that has carefully constructed output gates.
</pre>

<pre class=link-defaults>
spec:url; type:interface; text:URL
</pre>

<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        text: worklets; url: worklets.html#worklets
        text: relevant settings object; url: webappapis.html#relevant-settings-object
        text: obtaining a worklet agent; url: webappapis.html#obtain-a-worklet-agent
        text: environment; url: webappapis.html#environment
        text: environment settings object; url: webappapis.html#environment-settings-object
        text: relevant settings object; url: webappapis.html#relevant-settings-object
        text: target browsing context; url: webappapis.html#concept-environment-target-browsing-context
        text: active document; url: webappapis.html#active-document
        text: module script; url: webappapis.html#module-script
        text: module map; url: webappapis.html#module-map
        text: beginning navigation; url: webappapis.html#beginning-navigation
        text: ending navigation; url: webappapis.html#ending-navigation
        text: browsing context; for: Window; url: webappapis.html#window-bc
        text: node navigable; url: webappapis.html#node-navigable
        text: parent; for: navigable; url: webappapis.html#nav-parent
        text: get the top-level traversable; url: webappapis.html#nav-top
        text: top-frame; url: webappapis.html#top-level-traversable
        text: top-level traversable; url: webappapis.html#top-level-traversable
        text: opaque origin; url: browsers.html#concept-opaque-origin
        text: worklet global scope type; url: worklets.html#worklet-global-scope-type
        text: set up a worklet environment settings object; url: worklets.html#set-up-a-worklet-environment-settings-object
        text: parallel queue; url: infrastructure.html#parallel-enqueue
        text: enqueue the following steps; url: infrastructure.html#enqueue-the-following-steps
        text: browsing context; url: document-sequences.html#browsing-context
        text: active window; url: document-sequences.html#active-window
spec: html; urlPrefix: https://url.spec.whatwg.org
    type: dfn
        text: URL parser; url: concept-url-parser
        text: origin; for: url; url: concept-url-origin
spec: html; urlPrefix: https://dom.spec.whatwg.org/
    type: dfn
        text: origin; for: document; url: concept-document-origin
spec: html; urlPrefix: https://infra.spec.whatwg.org
    type: dfn
        text: user agent; url: user-agent
        text: string; url: string
        text: concatenate; for: string; url: string-concatenate
        text: map; url: ordered-map
        text: set; for: map; url: map-set
        text: get; for: map; url: map-get
        text: remove; url: map-remove
        text: clear; for: map; url: map-clear
        text: contains; for: map; url: map-exists
        text: key; for: map; url: map-key
        text: value; for: map; url: map-value
        text: entry; for: map; url: map-entry
        text: get the keys; url: map-getting-the-keys
        text: get the values; url: map-getting-the-values
        text: size; for: map; url: map-size
        text: empty; for: map; url: map-is-empty
        text: append; for: set; url: set-append
        text: list; url: list
        text: empty; for: list; url: list-is-empty
        text: append; for: list; url: list-append
        text: item; for: list; url: list-item
        text: struct; url: struct
        text: item; for: struct; url: struct-item
        text: queue; url: queue
        text: enqueue; for: queue; url: queue-enqueue
        text: dequeue; for: queue; url: queue-dequeue
spec: html; urlPrefix: https://webidl.spec.whatwg.org
    type: dfn
        text: upon fulfillment; url: upon-fulfillment
        text: upon rejection; url: upon-rejection
        text: promise; url: idl-promise
        text: promise resolved; url: a-promise-resolved-with
        text: promise rejected; url: a-promise-rejected-with
        text: dictionary; url: dfn-dictionary
        text: async iterator; url: idl-async-iterable
        text: asynchronous iterator initialization steps; url: asynchronous-iterator-initialization-steps
        text: get the next iteration result; url: dfn-get-the-next-iteration-result
        text: Web IDL Standard; url: introduction
spec: html; urlPrefix: https://storage.spec.whatwg.org/
    type: dfn
        text: storage model; url: model
        text: storage key; url: storage-key
        text: storage shed; url: storage-shed
        text: storage shelf; url: storage-shelf
        text: storage bucket; url: storage-bucket
        text: storage bottle; url: storage-bottle
        text: quota; for: storage bottle; url: storage-bottle-quota
        text: storage endpoint; url: storage-endpoint
        text: storage type; url: storage-type
        text: storage identifier; url: storage-identifier
        text: quota; for: storage endpoint; url: storage-endpoint-quota
        text: register; for: storage endpoint; url: registered-storage-endpoints
        text: bucket map; url: bucket-map
        text: bottle map; url: bottle-map
        text: storage proxy map; url: storage-proxy-map
        text: backing map; url: storage-proxy-map-backing-map
        text: proxy map reference set; url: storage-bottle-proxy-map-reference-set
spec: html; urlPrefix: https://w3c.github.io/beacon/
    type: dfn
        text: beacon; url: beacon
spec: html; urlPrefix: https://tc39.es/ecma262/
    type: dfn
        text: object; url: sec-object-type
        text: function; url: function-object
        text: call; url: sec-call
        text: IsConstructor(); url: sec-isconstructor
        text: constructor; url: constructor
        text: GetMethod(); url: sec-getmethod
        text: [[GetPrototypeOf]](); for: object; url: sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof
        text: assert; url: assert
spec: html; urlPrefix: https://w3c.github.io/hr-time/
    type: dfn
        text: unix epoch; url: dfn-unix-epoch
spec: html; urlPrefix: https://wicg.github.io/fenced-frame/
    type: dfn
        text: fenced frame; url: the-fencedframe-element
        text: url; for: FencedFrameConfig; url: dom-fencedframeconfig-url
        text: fence.reportEvent(); url: dom-fence-reportevent
        text: FenceEvent; url: dictdef-fenceevent
        text: destination; for: FenceEvent; url: dom-fenceevent-destination
        text: eventData; for: FenceEvent; url: dom-fenceevent-eventdata
        text: eventType; for: FenceEvent; url: dom-fenceevent-eventtype
    type: interface
        text: FencedFrameConfig; url: fencedframeconfig
spec: md; urlPrefix: https://github.com/patcg-individual-drafts/private-aggregation-api/blob/main/README.md
    type: dfn
        text: private aggregation
spec: html; urlPrefix: https://privacycg.github.io/storage-partitioning/
    type: dfn
        text: client-side storage partitioning
spec: md; urlPrefix: https://github.com/WICG/shared-storage
    type:dfn
        text: legitimate use cases; url: example-scenarios
spec: html; urlPrefix: https://en.wikipedia.org/wiki/Entropy_(information_theory)
    type: dfn
        text: bits of entropy
        text: entropy bits
</pre>

<style>
/* adapted from .XXX at https://resources.whatwg.org/standard.css */
.todo {
  color: #D50606;
  background: white;
  border: solid #D50606;
}

span.todo {
  padding-top: 0;
  padding-bottom: 0;
}

.todo::before { content: 'TODO: '; }

span.todo::before {
  left: 0;
  top: -0.25em;
}
</style>

Introduction {#intro}
=====================
<em>This section is not normative.</em>

In order to prevent cross-site user tracking, browsers are partitioning all forms of storage by [=top-frame=] site; see [=Client-Side Storage Partitioning=]. But, there are many [=legitimate use cases=] currently relying on unpartitioned storage.

This document introduces a new storage API that is intentionally not partitioned by [=top-frame=] site (though still partitioned by context origin), in order to serve a number of the use cases needing unpartitioned storage. To limit cross-site reidentification of users, data in Shared Storage may only be read in a restricted environment, called a worklet, and any output from the worklet is in the form of a [=fenced frame=] or a [=private aggregation|private aggregation report=]. Over time, there may be additional ouput gates included in the standard.

<div class="example">
  `a.example` randomly assigns users to groups in a way that is consistent cross-site.

  Inside an `a.example` iframe:
  <pre class="lang-js">
    function generateSeed() { … }
    await window.sharedStorage.worklet.addModule('experiment.js');

    // Only write a cross-site seed to a.example's storage if there isn't one yet.
    window.sharedStorage.set('seed', generateSeed(), { ignoreIfPresent: true });

    let fencedFrameConfig = await window.sharedStorage.selectURL(
      'select-url-for-experiment',
      [
        {url: "blob:https://a.example/123…", reportingMetadata: {"click": "https://report.example/1..."}},
        {url: "blob:https://b.example/abc…", reportingMetadata: {"click": "https://report.example/a..."}},
        {url: "blob:https://c.example/789…"}
      ],
      { data: { name: 'experimentA' } }
    );

    // Assumes that the fenced frame 'my-fenced-frame' has already been attached.
    document.getElementById('my-fenced-frame').config = fencedFrameConfig;
  </pre>

  inside the `experiment.js` worklet script:
  <pre class="lang-js">
    class SelectURLOperation {
      hash(experimentName, seed) { … }

      async run(data, urls) {
        const seed = await this.sharedStorage.get('seed');
        return hash(data.name, seed) % urls.length;
      }
    }
    register('select-url-for-experiment', SelectURLOperation);
  </pre>
</div>

The {{SharedStorageWorklet}} Interface {#worklet}
=================================================
The {{SharedStorageWorklet}} object allows developers to supply [=module scripts=] to process [=Shared Storage=] data and then output the result through one or more of the output gates. Currently there are two output gates, the [=private aggregation=] output gate and the {{WindowSharedStorage/selectURL()|URL-selection}} output gate.

<xmp class='idl'>
  [Exposed=(Window)]
  interface SharedStorageWorklet : Worklet {
  };
</xmp>

Each {{SharedStorageWorklet}} has an associated boolean <dfn>module added</dfn>, initialized to false.

Because adding multiple [=module scripts=] via {{Worklet/addModule()}} for the same {{SharedStorageWorklet}} would give the caller the ability to store data from [=Shared Storage=] in global variables defined in the [=module scripts=] and then exfiltrate the data through later call(s) to {{Worklet/addModule()}}, each {{SharedStorageWorklet}} can only call {{Worklet/addModule()}} once. The [=module added=] boolean makes it possible to enforce this restriction.

When {{Worklet/addModule()}} is called for a worklet, it will run [=check if module added and update status=], and if the result is true, abort the remaining steps in the {{Worklet/addModule()}} call, as detailed in the [[#worklet-monkey-patch]].

  <div algorithm>
    To <dfn>check if module added and update status</dfn> for a {{SharedStorageWorklet}} |worklet|, run the following steps:

    1. If |worklet|'s [=module added=] is true, return true.
    1. Otherwise, set {{Worklet}}'s [=module added=] to true.
    1. Return false.
  </div>

  ## Monkey Patch for [=Worklets=] ## {#worklet-monkey-patch}

  This specification will make some modifications to the [=Worklet=] standard to accommodate the needs of Shared Storage.

  In particular, the {{Worklet/addModule()}} method steps for {{Worklet}} will need to be prepended with the following step:

    0. If {{Worklet}} has an associated boolean [=module added=], and the result of running [=check if module added and update status=] on {{Worklet}} is true, return a [=promise rejected=] with a {{TypeError}}.

  <span class=todo>Add additional monkey patch pieces for out-of-process worklets.</span>

  ## The {{SharedStorageWorkletGlobalScope}} ## {#global-scope}

  The {{SharedStorageWorklet}}'s [=worklet global scope type=] is {{SharedStorageWorkletGlobalScope}}. 

  <xmp class='idl'>
    [Exposed=SharedStorageWorklet, Global=SharedStorageWorklet]
    interface SharedStorageWorkletGlobalScope : WorkletGlobalScope {
      undefined register(DOMString name,
                         SharedStorageOperationConstructor operationCtor);
    };

    callback SharedStorageOperationConstructor =
      SharedStorageOperation(optional SharedStorageRunOperationMethodOptions options);

    [Exposed=SharedStorageWorklet]
    interface SharedStorageOperation {
    };

    dictionary SharedStorageRunOperationMethodOptions {
      object data;
      boolean resolveToConfig = false;
      boolean keepAlive = false;
    };
  </xmp>

  Each {{SharedStorageWorkletGlobalScope}} has an associated [=environment settings object=] <dfn for=SharedStorageWorkletGlobalScope>outside settings</dfn>, which is the associated {{SharedStorageWorklet}}'s [=relevant settings object=]. 

  The {{SharedStorageWorkletGlobalScope}}'s [=module map=]'s [=module scripts=] should each define and {{register}} one or more {{SharedStorageOperation}}s. 

  Each {{SharedStorageWorkletGlobalScope}} also has an associated <dfn for=SharedStorageWorkletGlobalScope>operation map</dfn>, which is a [=map=], initially empty, of [=strings=] (denoting operation names) to [=functions=].

  Currently each {{SharedStorageOperation}} registered via {{SharedStorageWorkletGlobalScope/register()}} must be one of the following two types:
  * {{SharedStorageRunOperation}}
  * {{SharedStorageSelectURLOperation}}

  The {{SharedStorageRunOperation}} is designed to work with output gates that do not need a return value, like the [=private aggregation=] service. A {{SharedStorageRunOperation}} performs an async operation and returns a promise that resolves to undefined.

  A {{SharedStorageSelectURLOperation}} is an {{SharedStorageOperation}} that takes in a [=list=] of {{SharedStorageUrlWithMetadata}}s (i.e. [=dictionaries=] containing [=strings=] representing {{URL}}s each wrapped with optional metadata), performs an async operation, and then returns a promise to a {{long}} integer index specifying which of these {{URL}}s should be selected.

  <xmp class='idl'>
    [Exposed=SharedStorageWorklet]
    interface SharedStorageRunOperation : SharedStorageOperation {
      Promise<undefined> run(object data);
    };

    [Exposed=SharedStorageWorklet]
    interface SharedStorageSelectURLOperation : SharedStorageOperation {
      Promise<long> run(object data,
                        FrozenArray<SharedStorageUrlWithMetadata> urls);
    };
  </xmp>

  ## Registering a Worklet ## {#register-worklet}
  <div algorithm>
    The <dfn method for="SharedStorageWorkletGlobalScope">register(|name|, |operationCtor|)</dfn> method steps are:

    1. If |name| is missing or empty, throw a {{TypeError}}.
    1. Let |operationMap| be this {{SharedStorageWorkletGlobalScope}}'s [=SharedStorageWorkletGlobalScope/operation map=].
    1. If |operationMap| [=map/contains=] an [=map/entry=] with [=map/key=] |name|, throw a {{TypeError}}.
    1. If |operationCtor| is missing, throw a {{TypeError}}.
    1. If the result of running [=IsConstructor()=] with |operationCtor| is false, throw a {{TypeError}}.
    1. Let |prototype| be the result of running |operationCtor|'s [=object/[[GetPrototypeOf]]()=] method.
    1. If |prototype| is not an [=object=], throw a {{TypeError}}.
    1. Let |run| be the result of running [=GetMethod()=] with |prototype| and "`run`".
    1. If |run| is undefined, throw a {{TypeError}}.
    1. [=map/Set=] the value of |operationMap|[|name|] to |run|.
  </div>

Shared Storage's Backend {#backend}
===================================
The Shared Storage API will integrate into the [=Storage Model|Storage API=] as below, via [=storage endpoint/registering=] a new [=storage endpoint=].

  ## Monkey Patch for the [=Storage Model=] ## {#storage-monkey-patch}

  This standard will add a new [=storage type=] "`shared`" to the [=Storage Model=].

  A [=user agent=] holds a [=shared storage shed=] for [=storage endpoints=] of [=storage type|type=] "`shared`".

  This standard will also [=storage endpoint/register=] a [=storage endpoint=] of [=storage type|type=] "`shared`" with [=storage identifier=] "`sharedStorage`" and [=storage endpoint/quota=] `5`<sup>`4`</sup> `*` `2`<sup>`16`</sup> bytes (i.e. 39.0625 mebibytes).

  <span class=todo>This [=storage endpoint/quota=] is calculated from the current implementation. Consider bringing the current implementation in line with the spec for [=storage endpoints=] "`localStorage`" and "`sessionStorage`", i.e. `5 * 2`<sup>`20`</sup> bytes. For example, decreasing the per-origin entry limit from 10,000 to 1,280 would achieve this.</span>

  A <dfn>shared storage shed</dfn> is a [=map=] of [=/origins=] to [=storage shelf|storage shelves=]. It is initially empty.

  Note: Unlike [=storage sheds=], whose keys are [=storage keys=], [=shared storage sheds=] use [=/origins=] as keys directly. [=Shared storage=] will be intentionally excluded from [=client-side storage partitioning=].

  For each [=storage shelf=] in a [=shared storage shed=], the [=storage shelf=]'s [=bucket map=] currently has only a single key of "`default`".

  A [=user agent=]'s [=shared storage shed=] holds all <dfn>shared storage</dfn> data.

  <div algorithm>
    To <dfn>obtain a shared storage shelf</dfn>, given a [=shared storage shed=] |shed| and an [=environment settings object=] |environment|, run these steps:

    1. Let |origin| be |environment|'s [=url/origin=].
    1. If |origin| is an [=opaque origin=], then return failure.
    1. If the user has disabled [=shared storage=], then return failure.
    1. If |shed|[origin] does not exist, then set |shed|[origin] to the result of running [=create a shared storage shelf=] with [=storage type|type=] "`shared`".
    1. Return |shed|[|origin|].
  </div>

  <div algorithm>
    To <dfn>create a shared storage shelf</dfn>, run these steps:

    1. Let |shelf| be a new [=storage shelf=].
    1. Set |shelf|'s [=bucket map=]["`default`"] to the result of running [=create a shared storage bucket=].
    1. Return |shelf|.
  </div>

  A <dfn>shared storage bucket</dfn> is a [=storage bucket=] in one of a [=shared storage shed=]'s [=storage shelf|shelves=].

  <div algorithm>
    To <dfn>create a shared storage bucket</dfn>, run these steps:

    1. Let |endpoint| be the [=storage endpoint=] with [=storage identifier=] "`sharedStorage`".
    1. Let |bucket| be a new [=shared storage bucket=].
    1. Set |bucket|'s [=bottle map=]["`sharedStorage`"] to a new [=storage bottle=] whose [=storage bottle/quota=] is |endpoint|'s [=storage endpoint/quota=].
    1. Return |bucket|.
  </div>

  Note: Currently, a [=shared storage bucket=]'s [=bottle map=] has [=map/size=] `1`, since there is only one [=storage endpoint=] [=storage endpoint/registered=] with [=storage type|type=] "`shared`".

  <div algorithm>
    To <dfn>obtain a shared storage bottle map</dfn>, given an [=environment settings object=] |environment|, run these steps:

    1. Let |shed| be the [=user agent=]'s [=shared storage shed=].
    1. Let |shelf| be the result of running [=obtain a shared storage shelf=] with |shed| and |environment|.
    1. If |shelf| is failure, then return failure.
    1. Let |bucket| be |shelf|'s [=bucket map=]["`default`"].
    1. Let |bottle| be |bucket|'s [=bottle map=]["`sharedStorage`"].
    1. Let |proxyMap| be a new [=storage proxy map=] whose [=backing map=] is |bottle|'s [=map=].
    1. [=set/Append=] |proxyMap| to |bottle|'s [=proxy map reference set=].
    1. Return |proxyMap|.
  </div>

  ## The [=Shared Storage Database=] ## {#database}

  A [=/browsing context=] has an associated <dfn>shared storage database</dfn>, which provides methods to [=shared storage database/store an entry in the database|store=], [=shared storage database/retrieve an entry from the database|retrieve=], [=shared storage database/delete an entry from the database|delete=], [=shared storage database/clear all entries in the database|clear=], and [=shared storage database/purge expired entries from the database|purge expired=] data, and additional methods as below. The data in the [=shared storage database|database=] take the form of [=shared storage database/entry|entries=].

  Each [=shared storage database=] has a <dfn for="shared storage database">shared storage database queue</dfn>, which is the result of [=start a new parallel queue|starting a new parallel queue=]. This [=shared storage database queue|queue=] is used to run each of the [=shared storage database=]'s methods when calls to them are initiated from that [=/browsing context=].

  Each <dfn for="shared storage database">entry</dfn> consists of a [=entry/key=] and a [=entry/value struct=].

  An [=shared storage database/entry=]'s <dfn for=entry>key</dfn> is a [=string=].

  [=User agents=] may specify the <dfn for=key>maximum length</dfn> of a [=entry/key=].

  Since [=entry/keys=] are used to organize and efficiently retrieve [=shared storage database/entry|entries=], [=entry/keys=] must appear at most once in any given [=shared storage database=].

  An [=shared storage database/entry=]'s <dfn for=entry>value struct</dfn> is a [=struct=] composed of [=string=] <dfn for="value struct">value</dfn> and {{DOMHighResTimeStamp}} <dfn for="value struct">last updated</dfn> (from the [=Unix Epoch=]).

  [=User agents=] may specify the <dfn for=value>maximum length</dfn> of a [=value struct/value=].

  [=User agents=] may specify a <dfn>default entry lifetime</dfn>, the default [=duration=] between when an [=shared storage database/entry=] is [=shared storage database/store an entry in the database|stored=] and when it expires. If the [=user agent=] specifies a [=default entry lifetime=], then it should have a timer periodically [=shared storage database/purge expired entries from the database=].

  ## The [=Shared Storage Database|Database=] Algorithms ## {#database-algorithms}

  <div algorithm>
    To <dfn for="shared storage database">store an entry in the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue|, an [=environment settings object=] |environment|, a [=entry/key=] |key|, and a [=value struct/value=] |value|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return false.
    1. Let |valueStruct| be a new [=entry/value struct=].
    1. Set |valueStruct|'s [=value struct/value=] to |value|.
    1. Let |currentTime| be the [=current wall time=].
    1. Set |valueStruct|'s [=value struct/last updated=] to |currentTime|.
    1. [=map/Set=] |databaseMap|[|key|] to |valueStruct|.
    1. Return true.
  </div>

  <div algorithm>
    To <dfn for="shared storage database">retrieve an entry from the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue|, an [=environment settings object=] |environment|, and a [=entry/key=] |key|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return failure.
    1. If |databaseMap| does not [=map/contain=] |key|, return undefined.
    1. Let |valueStruct| be the result of running [=map/Get=] on |databaseMap| with |key|.
    1. If the result of running [=shared storage database/determine whether an entry is expired=] with |valueStruct| is true, return undefined.
    1. Return |valueStruct|'s [=value struct/value=].
  </div>

  <div algorithm>
    To <dfn for="shared storage database">delete an entry from the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue|, an [=environment settings object=] |environment|, and a [=entry/key=] |key|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return false.
    1. [=map/Remove=] |databaseMap|[|key|].
    1. Return true.
  </div>

  <div algorithm>
    To <dfn for="shared storage database">clear all entries in the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue| and an [=environment settings object=] |environment|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return false.
    1. Run [=map/Clear=] on |databaseMap|.
    1. Return true.
  </div>

  <div algorithm>
    To <dfn for="shared storage database">retrieve all entries from the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue| and an [=environment settings object=] |environment|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return failure.
    1. Return the result of running [=map/getting the values=] on |databaseMap|.
  </div>

  <div algorithm>
    To <dfn for="shared storage database">count entries in the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue| and an [=environment settings object=] |environment|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return failure.
    1. Return |databaseMap|'s [=map/size=].
  </div>

  <div algorithm>
    To <dfn for="shared storage database">purge expired entries from the database</dfn>, given a [=shared storage database/shared storage database queue=] |queue| and an [=environment settings object=] |environment|, run the following steps on |queue|:

    1. Let |databaseMap| be the result of running [=obtain a shared storage bottle map=] for |environment|.
    1. If |databaseMap| is failure, then return false.
    1. [=map/iterate|For each=] [=entry/key=] |key| in |databaseMap|:
        1. Let |valueStruct| be the result of running [=map/Get=] on |databaseMap| with |key|.
        1. If the result of running [=shared storage database/determine whether an entry is expired=] with |valueStruct| is true, [=map/Remove=] |databaseMap|[|key|].
    1. Return true.
  </div>

  <div algorithm>

    To <dfn for="shared storage database">determine whether an entry is expired</dfn>, given a [=entry/value struct=] |valueStruct|, run the following steps:

    1. Let |lastUpdated| be |valueStruct|'s [=value struct/last updated=].
    1. Let |lifetime| be [=user agent=]'s [=default entry lifetime=].
    1. Let |expiration| be the sum of |lastUpdated| and |lifetime|.
    1. Let |currentTime| be the [=current wall time=].
    1. If |expiration| is less than or equal to |currentTime|, return true.
    1. Otherwise, return false.
  </div>

The {{SharedStorage}} Interface {#shared-storage-interface}
==========================================================
The {{SharedStorage}} interface is the base for derived interfaces {{WindowSharedStorage}} and {{WorkletSharedStorage}}, which are exposed to the {{Window}} and the {{SharedStorageWorklet}}, respectively.

Methods that allow the setting and/or deleting of data are exposed to both the {{Window}} and the {{SharedStorageWorklet}} and hence are declared in the base {{SharedStorage}} interface, although their implementations may vary depending on their [=environment=]. This makes it possible to modify the data in Shared Storage from multiple contexts.

Meanwhile, methods for running {{SharedStorageOperation}}s, along with the {{WindowSharedStorage/worklet}} attribute which is used to call {{Worklet/addModule()}}, are declared in {{WindowSharedStorage}} and exposed to the {{Window}} only, as these are the means by which the {{Window}} interacts with the {{SharedStorageWorklet}}.

On the other hand, methods for getting data from the [=shared storage database=] are declared in {{WorkletSharedStorage}} and exposed to the {{SharedStorageWorklet}} only, in order to carefully control the flow of data read from the [=shared storage database|database=].

<xmp class='idl'>
  [Exposed=(Window,SharedStorageWorklet)]
  interface SharedStorage {
    Promise<any> set(DOMString key,
                     DOMString value,
                     optional SharedStorageSetMethodOptions options = {});
    Promise<any> append(DOMString key,
                        DOMString value);
    Promise<any> delete(DOMString key);
    Promise<any> clear();
  };

  dictionary SharedStorageSetMethodOptions {
    boolean ignoreIfPresent = false;
  };
</xmp>

  ## The {{WindowSharedStorage}} interface ## {#window}

  The {{WindowSharedStorage}} interface is as follows.

<xmp class='idl'>
  typedef (USVString or FencedFrameConfig) SharedStorageResponse;

  [Exposed=(Window)]
  interface WindowSharedStorage : SharedStorage {
    Promise<any> run(DOMString name,
                     optional SharedStorageRunOperationMethodOptions options = {});
    Promise<SharedStorageResponse> selectURL(DOMString name,
                                 FrozenArray<SharedStorageUrlWithMetadata> urls,
                                 optional SharedStorageRunOperationMethodOptions options = {});

    readonly attribute SharedStorageWorklet worklet;
  };
</xmp>

  ### Window Setter/Deleter Methods ### {#window-setter}

  <div algorithm>
    The <dfn method for="WindowSharedStorage">set(|key|, |value|, |options|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WindowSharedStorage}}'s {{Window}}'s [=Window/browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. If |value|'s [=string/length=] exceeds the [=value/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. If |options|["`ignoreIfPresent`"] is true and the result of running [=shared storage database/retrieve an entry from the database=] with |queue|, |environment|, and |key| is not undefined, resolve |promise| with undefined and abort these steps.
        1. Run [=shared storage database/store an entry in the database=] with |queue|, |environment|, |key|, and |value|.
        1. Resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WindowSharedStorage">append(|key|, |value|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WindowSharedStorage}}'s {{Window}}'s [=Window/browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. If |value|'s [=string/length=] exceeds the [=value/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Let |currentValue| be the result of running [=shared storage database/retrieve an entry from the database=] with |queue|, |environment|, and |key|.
        1. If |currentValue| is failure, resolve |promise| with undefined and abort these steps.
        1. If |currentValue| is not undefined:
            1. Let |list| be a new [=list=].
            1. [=list/Append=] |currentValue| to |list|.
            1. [=list/Append=] |value| to |list|.
            1. Set |value| to the result of running [=string/concatenate=] on |list|.
        1. Run [=shared storage database/store an entry in the database=] with |queue|, |environment|, |key|, and |value|.
        1. Resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WindowSharedStorage">delete(|key|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WindowSharedStorage}}'s {{Window}}'s [=Window/browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Run [=shared storage database/delete an entry from the database=] with |queue|, |environment|, and |key|.
        1. Resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WindowSharedStorage">clear()</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WindowSharedStorage}}'s {{Window}}'s [=Window/browsing context=].
    1. [=Assert=] that |context| is not null.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Run [=shared storage database/clear all entries in the database=] with |queue| and |environment|.
        1. Resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  ### {{SharedStorageUrlWithMetadata}} and Reporting ### {#reporting}

  A {{SharedStorageUrlWithMetadata}} {{/object}} is a [=dictionary=] containing a [=string=] representing a {{URL}} and, optionally, a {{reportingMetadata}} {{/object}}.

  <xmp class='idl'>
    dictionary SharedStorageUrlWithMetadata {
      required USVString url;
      object reportingMetadata;
    };
  </xmp>

  If a {{SharedStorageUrlWithMetadata}} {{/object}} contains a non-[=map/empty=] {{SharedStorageUrlWithMetadata/reportingMetadata}} {{/object}} in the form of a [=dictionary=] whose [=map/keys=] are [=FenceEvent/eventTypes=] and whose [=map/values=] are [=strings=] that parse to valid [=/URLs=], then these [=FenceEvent/eventType=]-[=/URL=] pairs will be [=register reporting metadata|registered=] for later access within any [=fenced frame=] that loads the {{SharedStorageResponse}} resulting from this {{WindowSharedStorage/selectURL()}} call.

  Inside a [=fenced frame=] with [=FenceEvent/eventType=]-[=/URL=] pairs that have been [=register reporting metadata|registered=] through {{WindowSharedStorage/selectURL()}} with {{SharedStorageUrlWithMetadata/reportingMetadata}} {{/object}}s, if [=fence.reportEvent()=] is called on a [=FenceEvent=] with a [=FenceEvent/destination=] [=list/containing=] "`shared-storage-select-url`" and that [=FenceEvent=]'s corresponding [=FenceEvent/eventType=] is triggered, then the [=FenceEvent=]'s [=FenceEvent/eventData=] will be sent as a [=beacon=] to the registered [=/URL=] for that [=FenceEvent/eventType=].

  <div algorithm>
    To <dfn>validate reporting metadata</dfn>, given an {{/object}} |reportingMetadata|, run the following steps:

    1. If |reportingMetadata| is [=map/empty=], return true.
    1. If |reportingMetadata| is not a [=dictionary=], return false.
    1. [=map/iterate|For each=] <var ignore="">eventType</var> -> |urlString| of |reportingMetadata|, if the result of running [=get the canonical URL string if valid=] with |urlString| is undefined, return false.
    1. Return true.
  </div>

  <div algorithm>
    To <dfn>get the canonical URL string if valid</dfn>, given a [=string=] |urlString|, run the following steps:

    1. Let |url| be the result of running a [=URL parser=] on |urlString|.
    1. If |url| is not a valid {{URL}}, return undefined.
    1. Otherwise, return the result of running a [=URL serializer=] on |url|.
  </div>

  <div algorithm>
    To <dfn>register reporting metadata</dfn>, given an {{/object}} |reportingMetadata| and a "fenced frame config struct" |fencedFrameConfigStruct|, run the following steps:

    1. If |reportingMetadata| is [=map/empty=], return.
    1. [=Assert=] that |reportingMetadata| is a [=dictionary=].
    1. Let |reportingUrlMap| be an [=map/empty=] [=map=].
    1. [=map/iterate|For each=] |eventType| -> |urlString| of |reportingMetadata|:
        1. Let |url| be the result of running a [=URL parser=] on |urlString|.
        1. [=Assert=] that |url| is a valid {{URL}}.
        1. [=map/Set=] |reportingUrlMap|[|eventType|] to |url|.
    1. <span class=todo>Store |reportingUrlMap| inside a "fenced frame reporter" class associated with |fencedFrameConfigStruct|. Both of these still need to be added to the draft [=fenced frame|Fenced Frame specification=].</span>
  </div>

  ### Entropy Budgets ### {#budgets}

  Because [=bits of entropy=] can leak via {{WindowSharedStorage/selectURL()}}, the [=user agent=] will need to maintain budgets to limit these leaks.

  #### Navigation Entropy Budget #### {#nav-budget}

  If a user activates a [=fenced frame=] whose {{FencedFrameConfig}} was generated by {{WindowSharedStorage/selectURL()}} and thereby initiates a [=top-frame=] [=navigate|navigation=], this will reveal to the landing page that its [=/URL=] was selected, which is a leak in [=entropy bits=] of up to logarithm base 2 of the number of input [=/URLs=] for the call to {{WindowSharedStorage/selectURL()}}. To mitigate this, a [=user agent=] will set a per-[=calling origin=] [=navigation entropy allowance=].

  A <dfn>calling origin</dfn> for {{WindowSharedStorage/selectURL()}} is the [=url/origin=] of an [=environment=] that makes a {{WindowSharedStorage/selectURL()}} call.

  A <dfn>navigation entropy allowance</dfn> is a maximum allowance of [=entropy bits=] that are permitted to leak via [=fenced frames=] initiating [=top-frame=] [=navigate|navigations=] during a given [=navigation budget epoch=] for a given calling [=calling origin=]. This [=navigation entropy allowance|allowance=] is defined by the [=user agent=] and is [=calling origin=]-agnostic.

  A [=user agent=] will define a fixed predetermined [=duration=] <dfn>navigation budget lifetime</dfn>.

  An <dfn>navigation budget epoch</dfn> is any interval of time whose [=duration=] is the [=navigation budget lifetime=].

  To keep track of how this [=navigation entropy allowance=] is used, the [=user agent=] uses a <dfn>shared storage navigation budget table</dfn>, which is a [=map=] of [=calling origins=] to [=navigation entropy ledgers=].

  An <dfn>navigation entropy ledger</dfn> is a [=list=] of [=bit debits=].

  A <dfn>bit debit</dfn> is a [=struct=] containing a {{double}} <dfn for="bit debit">bits</dfn>, indicating a value in [=entropy bits=], along with a {{DOMHighResTimeStamp}} <dfn for="bit debit">timestamp</dfn> (from the [=Unix Epoch=]).

  [=Bit debits=] whose [=bit debit/timestamps=] precede the start of the current [=navigation budget epoch=] are said to be <dfn for="bit debit">expired</dfn>.

  When a leak occurs, its value in [=entropy bits=] is calculated and stored for that [=calling origin=], along with the current time as a [=bit debit/timestamp=], together as a [=bit debit=] in the [=shared storage navigation budget table=].

  A [=calling origin=]'s <dfn for="calling origin">remaining navigation budget</dfn> is the [=navigation entropy allowance=] minus any [=bit debits=] whose [=bit debit/timestamps=] are within the current [=navigation budget epoch=].

  {{WindowSharedStorage/selectURL()}}'s argument "`urls`" is its <dfn for=selectURL>input URL list</dfn>.

  When an [=calling origin=] has insufficient [=calling origin/remaining navigation budget=], {{WindowSharedStorage/selectURL()}} will return a {{SharedStorageResponse}} (i.e. either a {{FencedFrameConfig}} or an opaque [=/URL=]) for the {{SharedStorageUrlWithMetadata/url}} in the {{SharedStorageUrlWithMetadata}} at the [=default index=] in its [=selectURL/input URL list=].

  The <dfn>default index</dfn> for a call to {{WindowSharedStorage/selectURL()}} is implementation-defined in such a way that it is independent from the result of the associated {{SharedStorageSelectURLOperation}}'s "`run`" method.

  <div class="example">
    The [=default index=] could be defined to be 0.

    In this case, whenever the {{SharedStorageSelectURLOperation}}'s "`run`" method encounters an error, or whenever there is insufficient [=calling origin/remaining navigation budget=], the "`run`" method would return 0, and hence {{WindowSharedStorage/selectURL()}} would return a {{SharedStorageResponse}} for the first {{SharedStorageUrlWithMetadata/url}} in its [=selectURL/input URL list=].
  </div>

  <div class="example">
    The [=default index=] could be defined to be [=selectURL/input URL list=]'s [=list/size=] minus 1.

    In this case, whenever the {{SharedStorageSelectURLOperation}}'s "`run`" method encounters an error, or whenever there is insufficient [=calling origin/remaining navigation budget=], {{WindowSharedStorage/selectURL()}} would return a {{SharedStorageResponse}} for the last {{SharedStorageUrlWithMetadata/url}} in its [=selectURL/input URL list=].
  </div>

  <div algorithm>
    To <dfn>determine remaining navigation budget</dfn>, given a calling [=calling origin=] |origin|, run the following steps:

    1. If |origin| is [=opaque origin|opaque=], return undefined.
    1. Let |maxBits| be the [=user agent=]'s [=navigation entropy allowance=].
    1. If the [=user agent=]'s [=shared storage navigation budget table=] does not [=map/contain=] |origin|, then return |maxBits|.
    1. Otherwise, let |ledger| be [=user agent=]'s [=shared storage navigation budget table=][|origin|].
    1. Let |debitSum| be 0.
    1. [=map/iterate|For each=] [=list/item=] |bitDebit| in |ledger|, do the following steps:
        1. Let |debit| be |bitDebit|'s [=bit debit/bits=].
        1. If the result of running [=check whether a bit debit is expired=] with |bitDebit| is false, then increment |debitSum| by |debit|.
    1. Return |maxBits| minus |debitSum|.
  </div>

  <div algorithm>
    To <dfn>check whether a bit debit is expired</dfn>, given a [=bit debit=] |bitDebit|, run the following steps:

    1. Let |epochLength| be the [=user agent=]'s [=navigation budget lifetime=].
    1. Let |currentTime| be the [=current wall time=].
    1. Let |threshold| be |currentTime| minus |epochLength|.
    1. If |bitDebit|'s [=bit debit/timestamp=] is less than |threshold|, return true.
    1. Otherwise, return false.
  </div>


  A [=bit debit=] will need to be [=charge shared storage navigation budget|charged=] to the [=shared storage navigation budget table=] for each [=top-frame=] [=navigate|navigation=] initiated by a [=fenced frame=] whose {{FencedFrameConfig}} was generated via {{WindowSharedStorage/selectURL()}}, as this can leak cross-site data. Since the [=bit debit/bits=] to charge is calculated during the call to {{WindowSharedStorage/selectURL()}} but only actually recorded in the [=shared storage navigation budget table=] if and when the resulting fenced frame initiates a [=top-frame=] [=beginning navigation|navigation=], the [=bit debit/bits=] must be stored as a <dfn>pending shared storage budget debit</dfn> in the corresponding {{FencedFrameConfig}} until this time.

  Between [=beginning navigation=] and [=ending navigation=], a [=user agent=] will perform the [=charge shared storage navigation budget=] algorithm.

  Issue: The "fenced frame config struct" and its boolean <dfn>has navigated</dfn> have not yet been added to the draft [=Fenced Frame=] specification. Some form of them will be added, although their names are subject to bikeshedding. <span class=todo>Fix the names when they are added.</span>

  <div algorithm>
    To <dfn>charge shared storage navigation budget</dfn> during a [=beginning navigation|navigation=] with [=navigable=] |navigable| and {{Document}} |sourceDocument|, run the following steps:

    1. If |navigable| is not a [=navigable/traversable navigable=], return.
    1. Let |node| be |sourceDocument|'s [=node navigable=].
    1. While |node| is not null:
        1. If |node| has a "fenced frame config struct":
            1. Let |origin| be |node|'s [=active document=]'s [=document/origin=].
            1. Let |pendingBits| be |node|'s "fenced frame config struct"'s [=pending shared storage budget debit=].
            1. If |pendingBits| is greater than 0 and if "fenced frame config struct"'s [=has navigated=] is false, run the following steps:
                1. Let |ledger| be [=user agent=]'s [=shared storage navigation budget table=][|origin|].
                1. Let |bitDebit| be a new [=bit debit=].
                1. Set |bitDebit|'s [=bit debit/bits=] to |pendingBits|.
                1. Let |currentTime| be the [=current wall time=].
                1. Set |bitDebit|'s [=bit debit/timestamp=] to |currentTime|.
                1. [=list/Append=] |bitDebit| to |ledger|.
                1. Set |node|'s "fenced frame config struct"'s [=has navigated=] to true.
        1. Set |node| to |node|'s [=navigable/parent=].
  </div>

  #### Reporting Entropy Budget #### {#report-budget}

  Likewise, each time a call to [=fence.reportEvent()=] from a [=fenced frame=] originating via {{WindowSharedStorage/selectURL()}} whose [=FenceEvent/destination=] [=list/contains=] "`shared-storage-select-url`" and whose [=FenceEvent/eventType=] is triggered, there is a leak of up to logarithm base 2 of the number of main input [=/URLs=] [=entropy bits=]. The [=user agent=] will need to set a per-[=page load=] [=reporting entropy allowance=] to restrict the information leaked, with <dfn>page load</dfn> referring to a [=top-level traversable=]'s lifecycle.

  A <dfn>reporting entropy allowance</dfn> is a maximum allowance of [=entropy bits=] that are permitted to leak via [=fence.reportEvent()=] during a given page load. This [=reporting entropy allowance|allowance=] is defined by the [=user agent=].

  Each [=top-level traversable=] will have a new {{double}} <dfn>shared storage reporting budget</dfn> associated to it which will be initialized with the value of [=user agent=]'s [=reporting entropy allowance=] upon [=top-level traversable=]'s creation. 

  When [=fence.reportEvent()=] is called with a [=FenceEvent/destination=] [=list/containing=] "`shared-storage-select-url`", it will be necessary to [=charge shared storage reporting budget=] as below.

  <div algorithm>
    To <dfn>determine reporting budget to charge</dfn>, given a {{Document}} |sourceDocument|, run the following steps:

    1. Let |debitSum| be 0.
    1. Let |node| be |sourceDocument|'s [=node navigable=].
    1. While |node| is not null:
        1. If |node| has a "fenced frame config struct":
            1. Let |pendingBits| be |node|'s "fenced frame config struct"'s [=pending shared storage budget debit=].
            1. If |pendingBits| is greater than 0 and if "fenced frame config struct"'s [=has reported=] is false, increment |debitSum| by |pendingBits|
        1. Set |node| to |node|'s [=navigable/parent=].
    1. Return |debitSum|.
  </div>


  Issue: The "fenced frame config struct" and its boolean <dfn>has reported</dfn> have not yet been added to the draft [=Fenced Frame=] specification. Some form of them will be added, although their names are subject to bikeshedding. <span class=todo>Fix the names when they are added.</span>

  <div algorithm>
    To <dfn>charge shared storage reporting budget</dfn> given a {{Document}} |sourceDocument|, run the following steps:

    1. Let |toCharge| be the result of running [=determine reporting budget to charge=] with |sourceDocument|.
    1. Let |node| be |sourceDocument|'s [=node navigable=].
    1. Let |topNode| be the result of running [=get the top-level traversable=] for |node|.
    1. If |topNode|'s [=shared storage reporting budget=] is less than |toCharge|, return false.
    1. While |node| is not null:
        1. If |node| has a "fenced frame config struct" and if |node|'s "fenced frame config struct"'s [=pending shared storage budget debit=] is greater than 0, set |node|'s "fenced frame config struct"'s [=has reported=] to true.
        1. Set |node| to |node|'s [=navigable/parent=].
    1. Decrement |topNode|'s [=shared storage reporting budget=] by |toCharge|.
    1. Return true.
  </div>


  A [=user agent=] may wish to set a timer to periodically [=purge expired bit debits from all navigation entropy ledgers=], as the [=bit debit/expired=] [=bit debits=] will no longer be needed.

  <div algorithm>
    To <dfn>purge expired bit debits from all navigation entropy ledgers</dfn>, run the following steps:

    1. [=map/iterate|For each=] <var ignore="">origin</var> -> |ledger| of [=user agent=]'s [=shared storage navigation budget table=]:
        1. [=map/iterate|For each=] |bitDebit| in |ledger|, if the result of running [=check whether a bit debit is expired=] with |bitDebit| is true, [=list/remove=] |bitDebit| from |ledger|.
  </div>

  ### Run Operation Methods ### {#run-op}

  <div algorithm>
    The <dfn method for="WindowSharedStorage">run(|name|, |options|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. If {{Worklet/addModule()}} has not yet been called, return a [=promise rejected=] with a {{TypeError}}.
    1. Let |outsideSettings| be {{WindowSharedStorage/worklet}}'s [=relevant settings object=].
    1. Let |agent| be the result of [=obtaining a worklet agent=] given |outsideSettings|.
    1. Run the following steps in |agent|:
        1. If {{WindowSharedStorage/worklet}}'s [=module map=] is not [=map/empty=]:
            1. Let |operationMap| be this {{SharedStorageWorkletGlobalScope}}'s [=SharedStorageWorkletGlobalScope/operation map=].
            1. If |operationMap| [=map/contains=] |name|:
                1.  Let |operation| be |operationMap|[|name|].
                1. If |options| [=map/contains=] |data|:
                    1. Let |argumentsList| be a new [=list=].
                    1. [=list/Append=] |data| to |argumentsList|.
                    1. [=Call=] |operation| with |argumentsList|.
                1. Otherwise, [=call=] |operation| without any arguments list.
        1. Resolve |promise| with undefined.
    1. Return |promise|.
    1. If |options|["`keepAlive`"] is false, [=upon fulfillment=] of |promise| or [=upon rejection=] of |promise|, run [=terminate a worklet global scope=] with the associated {{SharedStorageWorkletGlobalScope}}.
  </div>

  <div algorithm>
    The <dfn method for="WindowSharedStorage">selectURL(|name|, |urls|, |options|)</dfn> method steps are:

    1. Let |resultPromise| be a new [=promise=].
    1. If |urls| is empty or exceeds the maximum allowed length, return a [=promise rejected=] with a {{TypeError}}.
    1. Let |urlList| be an empty {{list}}.
    1. [=map/iterate|For each=] |urlWithMetadata| in |urls|:
        1. If |urlWithMetadata| has no field "`url`", return a [=promise rejected=] with a {{TypeError}}.
        1. Otherwise, let |urlString| be |urlWithMetadata|["`url`"].
        1. Let |serializedUrl| be the result of running [=get the canonical URL string if valid=] with |urlString|.
        1. If |serializedUrl| is undefined, return a [=promise rejected=] with a {{TypeError}}.
        1. Otherwise, [=list/append=] |serializedUrl| to |urlList|.
        1. If |urlWithMetadata| has field "`reportingMetadata`":
            1. Let |reportingMetadata| be |urlWithMetadata|["`reportingMetadata`"].
            1. If the result of running [=validate reporting metadata=]  with |reportingMetadata| is false, reject |promise| with a {{TypeError}} and abort these steps.
    1. If {{Worklet/addModule()}} has not yet been called, reject |promise| with a {{TypeError}} and abort these steps.
    1. Let |fencedFrameConfigStruct| be a "fenced frame config struct". <span class=todo>Add correct struct name as well as linking when Fenced Frame API updates their draft spec to include it.</span>

    Issue: The "fenced frame config struct" and the following "obtain a {{FencedFrameConfig}} from a fenced frame config struct" algorithm have not yet been added to the draft [=Fenced Frame=] specification. Some form of them will be added, although their names are subject to bikeshedding.

    1. If |options|["`resolveToConfig`"] is true, resolve |resultPromise| with the result of running "obtain a {{FencedFrameConfig}} from a fenced frame config struct" with |fencedFrameConfigStruct|. <span class=todo>Add correct struct and algorithms names as well as linking when Fenced Frame API updates their draft spec to include it.</span>
    1. Othewise, resolve |resultPromise| to |fencedFrameConfigStruct|'s "urn uuid". <span class=todo>Add correct struct name and urn:uuid name as well as linking when Fenced Frame API updates their draft spec to include it.</span>
    1. Let |indexPromise| be a new [=promise=].
    1. Let |outsideSettings| be {{WindowSharedStorage/worklet}}'s [=relevant settings object=].
    1. Let |agent| be the result of [=obtaining a worklet agent=] given |outsideSettings|.
    1. Run the following steps in |agent|:
        1. Let |index| be [=default index=].
        1. If {{WindowSharedStorage/worklet}}'s [=module map=] is not [=map/empty=]:
            1. Let |operationMap| be the associated {{SharedStorageWorkletGlobalScope}}'s [=SharedStorageWorkletGlobalScope/operation map=].
            1. If |operationMap| [=map/contains=] |name|:
                1.  Let |operation| be |operationMap|[|name|].
                1. Let |argumentsList| be a new [=list=].
                1. [=list/Append=] |urlList| to |argumentsList|.
                1. If |options| [=map/contains=] |data|, [=list/append=] |data| to |argumentsList|.
                1. Let |operationResult| be the result of running [=Call=] on |operation| with |argumentsList|.
                1. If |operationResult| has any error(s), then reject |indexPromise| with a {{TypeError}}.
                1. Otherwise:
                    1. Set |index| to the result of casting |operationResult| to an {{unsigned long}}. If this throws an exception, catch it and reject |indexPromise| with a {{TypeError}}.
                    1. Otherwise, if |index| is greater than |urlList|.[=list/size=], then reject |indexPromise| with a {{TypeError}}.
        1. If |indexPromise| has not been rejected, resolve |indexPromise| with |index|.
        1. [=Upon fulfillment=] of |indexPromise|, perform the following steps:
            1. Let |resultIndex| be the numerical value of |indexPromise|.
            1. Let |context| be {{WindowSharedStorage}}'s {{Window}}'s [=Window/browsing context=].
            1. [=Assert=] that |context| is not null.
            1. Let |origin| be |context|'s [=active document=]'s [=url/origin=].
            1. [=Assert=] that |origin| is not [=opaque origin|opaque=].
            1. Let |remainingBudget| be the result of running [=determine remaining navigation budget=] with |origin|.
            1. [=Assert=] that |remainingBudget| is not undefined.
            1. Let |listSize| be |urlList|'s [=list/size=].
            1. Let |pendingBits| be the logarithm base 2 of |listSize|.
            1. If |pendingBits| is greather than |remainingBudget|, set |resultIndex| to [=default index=].
            1. Set |fencedFrameConfigStruct|'s [=pending shared storage budget debit=] to |pendingBits|.
            1. Set |fencedFrameConfigStruct|'s [=/url=] to |urlList|[|resultIndex|].
            1. Let |resultURLWithMetadata| be |urls|[|resultIndex|].
            1. If |resultURLWithMetadata| has field "`reportingMetadata`", run [=register reporting metadata=] with |resultURLWithMetadata|["`reportingMetadata`"].
        1. [=Upon rejection=] of |indexPromise|, set |fencedFrameConfigStruct|'s [=/url=] to |urlList|[[=default index=]].
    1. Return |resultPromise|.
    1. If |options|["`keepAlive`"] is false, [=upon fulfillment=] of |resultPromise| or [=upon rejection=] of |resultPromise|, run [=terminate a worklet global scope=] with the associated {{SharedStorageWorkletGlobalScope}}.
  </div>

  ## The {{WorkletSharedStorage}} interface ## {#worklet-shared-storage}

  The {{WorkletSharedStorage}} interface is as follows.

<xmp class='idl'>
  [Exposed=(SharedStorageWorklet)]
  interface WorkletSharedStorage : SharedStorage {
    Promise<DOMString> get(DOMString key);
    Promise<unsigned long> length();
    Promise<double> remainingBudget();

    async iterable<DOMString, DOMString>;
  };
</xmp>

  ### Worklet Setter/Deleter Methods ### {#worklet-setter}

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">set(|key|, |value|, |options|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. If |value|'s [=string/length=] exceeds the [=value/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. If |options|["`ignoreIfPresent`"] is true:
            1. Let |currentValue| be the result of running [=shared storage database/retrieve an entry from the database=] with |queue|, |environment|, and |key|.
            1. If |currentValue| is failure, reject |promise| with a {{TypeError}} and abort these steps.
            1. If |currentValue| is not undefined, resolve |promise| with undefined and abort these steps.
        1. If the result of running [=shared storage database/store an entry in the database=] with |queue|, |environment|, |key|, and |value| is false, reject |promise| with a {{TypeError}}.
        1. Otherwise, resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">append(|key|, |value|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. If |value|'s [=string/length=] exceeds the [=value/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Let |currentValue| be the result of running [=shared storage database/retrieve an entry from the database=] with |queue|, |environment|, and |key|.
        1. If |currentValue| is failure, reject |promise| with a {{TypeError}} and abort these steps.
        1. If |currentValue| is not undefined:
            1. Let |list| be a new [=list=].
            1. [=list/Append=] |currentValue| to |list|.
            1. [=list/Append=] |value| to |list|.
            1. Set |value| to the result of running [=string/concatenate=] on |list|.
        1. If the result of running [=shared storage database/store an entry in the database=] with |queue|, |environment|, |key|, and |value| is false, reject |promise| with a {{TypeError}}.
        1. Otherwise, resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">delete(|key|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. If the result of running [=shared storage database/delete an entry from the database=] with |queue|, |environment|, and |key| is false, reject |promise| with a {{TypeError}}.
        1. Otherwise, resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">clear()</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. If the result of running [=shared storage database/clear all entries in the database=] with |queue| and |environment| is false, reject |promise| with a {{TypeError}}.
        1. Otherwise, resolve |promise| with undefined.
    1. Return |promise|.
  </div>

  ### Getter Methods ### {#getter}

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">get(|key|)</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. If |key|'s [=string/length=] exceeds the [=key/maximum length=], return a [=promise rejected=] with a {{TypeError}}.
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Let |value| be the result of running [=shared storage database/retrieve an entry from the database=] with |queue|, |environment|, and |key|.
        1. If |value| is failure, reject |promise| with a {{TypeError}}.
        1. Otherwise, if |value| is undefined, resolve |promise| with undefined.
        1. Otherwise, resolve |promise| with |value|.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">length()</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Let |numEntries| be the result of running [=shared storage database/count entries in the database=] with |queue| and |environment|.
        1. If |numEntries| is failure, reject |promise| with a {{TypeError}}.
        1. Otherwise, resolve |promise| with |numEntries|.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method for="WorkletSharedStorage">remainingBudget()</dfn> method steps are:

    1. Let |promise| be a new [=promise=].
    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. Let |origin| be |context|'s [=active document=]'s [=document/origin=].
    1. [=Assert=] that |origin| is not [=opaque origin|opaque=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Let |remainingBudget| be the result of running [=determine remaining navigation budget=] with |origin|.
        1. [=Assert=] that |remainingBudget| is not undefined.
        1. Resolve |promise| with |remainingBudget|.
    1. Return |promise|.
  </div>

  ### Iteration ### {#iteration}

  Each {{WorkletSharedStorage}} [=async iterator=] instance has a [=queue=] <dfn for=WorkletSharedStorageIterator>pending entries</dfn> of [=shared storage database/entry|entries=], initially [=list/empty=].

  Each {{WorkletSharedStorage}} [=async iterator=] instance also has a {{boolean}} <dfn for=WorkletSharedStorageIterator>error</dfn>, initially false.

  The [=WorkletSharedStorageIterator/asynchronous iterator initialization steps=] and [=WorkletSharedStorageIterator/get the next iteration result=] algorithms defined below correspond to those referred to as the [=/asynchronous iterator initialization steps=] and [=/get the next iteration result=] algorithms in the [=Web IDL Standard=].

  <div algorithm>
    The <dfn for="WorkletSharedStorageIterator">asynchronous iterator initialization steps</dfn> for a {{WorkletSharedStorage}} [=async iterator=] |iterator| are:

    1. Let |context| be {{WorkletSharedStorage}}'s {{SharedStorageWorkletGlobalScope}}'s [=outside settings=]'s [=target browsing context=].
    1. [=Assert=] that |context| is not null.
    1. Let |promise| be a new [=promise=].
    1. Let |environment| be |context|'s [=active window=]'s [=relevant settings object=].
    1. Let |queue| be |context|'s associated [=shared storage database/shared storage database queue=].
    1. [=Enqueue the following steps=] on |queue|:
        1. Let |entries| be the result of running [=shared storage database/retrieve all entries from the database=] with |queue| and |environment|.
        1. If |entries| is failure, reject |promise| with a {{TypeError}}.
        1. Otherwise, resolve |promise| with |entries|.
    1. [=Upon fulfillment=] of |promise|, run the following:
        1. Let |promiseEntries| be the value of |promise|.
        1. [=map/iterate|For each=] [=shared storage database/entry=] |entry| in |promiseEntries|, [=queue/enqueue=] |entry| in |iterator|'s [=WorkletSharedStorageIterator/pending entries=].
    1. [=Upon rejection=] of |promise|, set |iterator|'s [=WorkletSharedStorageIterator/error=] to true.
  </div>

  <div algorithm>
    To<dfn for="WorkletSharedStorageIterator">get the next iteration result</dfn>, given a {{WorkletSharedStorage}}'s [=async iterator=] |iterator|, run the following steps:

    1. Let |promise| be a new [=promise=].
    1. [=Enqueue the following steps=]:
        1. If |iterator|'s [=WorkletSharedStorageIterator/error=] is true, return a [=promise rejected=] with a {{TypeError}}.
        1. If |iterator|'s [=WorkletSharedStorageIterator/pending entries=] is [=list/empty=]:
            1. Create an object |doneObject|.
            1. Resolve |promise| with |doneObject| and abort these steps.
        1. Otherwise, let |entry| be the result of [=queue/dequeue|dequeueing=] from |iterator|'s [=WorkletSharedStorageIterator/pending entries=].
        1. Resolve |promise| with |entry|.
    1. Return |promise|.
  </div>

Privacy Considerations {#privacy}
=================================

  The Shared Storage API attempts to provide the ability to use cross-site data for a range of use cases in a way that better protects user privacy than the use of third-party cookies. Shared Storage's main privacy safeguard is that read access of the data stored in its storage may only occur within an embedder's {{SharedStorageWorklet}}. Well-defined limits restrict output of data from the {{SharedStorageWorklet}} to a minimum.

  In particular, an embedder can select a [=/URL=] from a short list of [=/URL=]s based on data in their shared storage and then display the result in a [=fenced frame=]. The embedder will not be able to know which [=/URL=] was chosen except through specifc mechanisms that will be better-mitigated in the longer term. Currently, a few bits of entropy can leak each time that the user clicks on the [=fenced frame=] to initiate a [=top-frame=] [=navigate|navigation=] and/or the [=fenced frame=] calls the [=fence.reportEvent()=] API.

  An embedder is also able to send aggregatable reports through the [=Private Aggregation|Private Aggregation Service=], which adds noise in order to achieve differential privacy, uses a time delay to send reports, imposes limits on the number of reports sent, and processes the reports into aggregate data so that individual privacy is protected.
